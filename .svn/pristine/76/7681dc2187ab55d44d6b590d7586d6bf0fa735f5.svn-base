/**
  ******************************************************************************
  * @file    loRa_NUCLEO_FreeRTOS/source/main.c
  * @author  Daniel Gala Montes
  * @brief   This example describes how to configure and use a LoRa module through
  *          the STM32L4xx HAL API.
  ******************************************************************************
**/

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "halLora.h"
#include "radio.h"

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
static GPIO_InitTypeDef  GPIO_InitStruct;
xTaskHandle testLoraMultipleTask_Handle;
xTaskHandle testLoraTimerTask_Handle;
xTaskHandle testLoraTimer2Task_Handle;

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
void TestLoraTimer_Task();
void TestLoraTimer2_Task();
void TestLoraMultiple_Task();

/* Private functions ---------------------------------------------------------*/

// ************************************************************
// TestLoraTimer_Task
// Corresponde a un timer para cada un segundo
// ************************************************************
void TestLoraTimer_Task()
{
	contadorSeg_TX = 0;
	contadorSeg_RX = 0;

	while(1)
	{
		if(RADIO.statusRXTX == RADIO_TX)
		{
			contadorSeg_TX++;
		}
		else if(RADIO.statusRXTX == RADIO_RX)
		{
			contadorSeg_RX++;
		}
    contadorSegSensor++;
		vTaskDelay(1000);
	}
}

// ************************************************************
// TestLoraTimer2_Task
// Desfase de tiempo para TX con aplicación punto-multipunto
// ************************************************************
void TestLoraTimer2_Task()
{
	contador200mS = 0;

	while(1)
	{
		contador200mS = contador200mS + 1;
		vTaskDelay(200);
	}
}

/********************************************************************************
 TestLoraMultiple_Task
 Prueba para puesta en funcionamiento de LORA: demo Multipunto - Esclavo
********************************************************************************/
void TestLoraMultiple_Task()
{
  u1_t segundosEsperaTX 	= 2;
  u1_t segundosEsperaRX 	= 5;

  u1_t NumeroMaestro = 0;            //Define el numero del maestro
  u1_t NumeroEsclavo = 1;            //Define el numero del esclavo
  u1_t VariableEsclavo = 0;            //Define la variable enviada por el esclavo
  u1_t tiempoTomaMuestraSensor = 30;   //Segundos de toma de muestra

  u1_t NumTiemDesfaseTX;

  u1_t flagEnvio             = 0;
  u2_t CONTADOR = 0x0000;
  u1_t SENSOR[4];
  u2_t contadorBytesRX = 0x0000;

  //Tramas utilizadas para enviar o recibir
  u1_t envioSensor[8] = {NumeroMaestro, NumeroEsclavo, VariableEsclavo, 0, 0, 0, 0, 0};              //los ultimos 4 bytes funcionan como dato tomado del sensor
  //envioSensor 0_NumeroMaestro{0}   1_NumeroEsclavo{1-3}   2_VariableEsclavo{0-255}   3-> Numero random de la trama      4-7-> Dato

  u1_t recibidoConfirmacion[4];
  //recibidoConfirmacion   0->Destino  1-> Fuente  2-> tipo sensor  3->Numero random de la trama

  //Almacenamiento TRAMAS
  u1_t tramaPendienteTX[200];
  u1_t cantidadPendienteTX;
  u1_t NumeroRandomTrama;

  u1_t i,j;						//uso general
  u2_t mult;						//Uso general

  //Inicializacion variable globales
  contadorSeg_TX = 0;
  contadorSeg_RX = 0;
  contador200mS = 0;
  contadorSegSensor = 0;

  //Configuracion de parametros
  RADIO.flagTx = 0;      //Inicializacion de variables
  RADIO.flagRx = 0;
  RADIO.crc 	 = 0;

  memset(tramaPendienteTX, 0, 200);
  cantidadPendienteTX = 0;

  //SX1278
  RADIO.freq = 433800000;   // Use a frequency in the g3 which allows 10% duty cycling.
  RADIO.txpow = 17;      // Maximum TX power
  RADIO.imax = 100;          //Por defecto 100mA   45mA <=Imax <= 240mA

  //{ CR_4_5, CR_4_6, CR_4_7, CR_4_8 };					//Usado para CR
  //{ SF_6, SF_7, SF_8, SF_9, SF_10, SF_11, SF_12 };		//Usado para SF
  //{ BW7_8, BW10_4, BW15_6, BW20_8, BW31_25, BW41_7, BW62_5, BW125, BW250, BW500, BWrfu };

  RADIO.sf = SF_9;              //Configuracion del Modem SF a baja velocidad
  RADIO.bw = BW500;              //Configuracion del ancho de banda reducido
  RADIO.cr = CR_4_5;              //Configuracion de Coding rate

  RADIO.statusRXTX = RADIO_RST;  //Se incorpora para modificar en el main*loop

  hal_init();						//inicia el hardware
  radio_init();					//inicia el radio

  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn); //Activación de las interrupciones por DIO0

  CONTADOR = 1000*NumeroEsclavo;

  srand((unsigned int)(&i));
  NumTiemDesfaseTX = (rand() % 50);					//Establece un randon entre 0-50

  //cargarSensor_TramaPendienteTX();        //incrementa la cantidad pendientes de tramas, ademas de Simula el valor del SENSOR
  contadorSegSensor = tiempoTomaMuestraSensor;			//FORZA que se entre a la parte final cargarSensor_TramaPendienteTX
  cantidadPendienteTX =0;

  while(1)
  {
    if((cantidadPendienteTX>0) && ((contador200mS - NumTiemDesfaseTX) > 0) && (flagEnvio == 0) && (RADIO.statusRXTX == RADIO_RST))        // RADIO.flags != 0
    {

      radio_mode(RADIO_RST);                                  //Detiene la RX antes
      flagEnvio = 1;
      contador200mS = 0;                                    //Coloca el contador de 200mS -> 0
      RADIO.flagTx = 0;
      RADIO.statusRXTX = RADIO_TX;                         //Flag para determinar donde esta el LORA-> esto se puede hacer desde dentro las librerias

      NumeroRandomTrama = tramaPendienteTX[0];
      envioSensor[3] = NumeroRandomTrama;               //Este numero se utilizara para comprobar que se TX

      radio_buffer_to_frameTX(envioSensor, 8);                  //Carga 8 bytes a la FIFO de LORa-> Activa TX
      radio_mode(RADIO_TX);     //Configura la TX

      contadorSeg_TX=0;                         //Inicializa contador de seg TX
      contadorSeg_RX=0;                         //Inicializa contador de seg RX
    }
    if((flagEnvio == 1)  && (RADIO.flagTx == 1))         //Ha recibido la confirmacion del modem por TX correcta
    {
      flagEnvio = 0;
      RADIO.flagTx = 0;
      RADIO.flagRx = 0;

      radio_mode(RADIO_RX);                     //Pasa a MODO RX
      RADIO.statusRXTX = RADIO_RX;             // Utilizado como flag coloca la variable de modo en RX
      contadorSeg_RX=0;                         //Inicializa contador de seg RX
      contadorSeg_TX=0;                         //Inicializa contador de seg TX
    }
    if (((contadorSeg_TX - segundosEsperaTX) >= 0) && (RADIO.statusRXTX == RADIO_TX))
    {
      flagEnvio = 0;
      RADIO.statusRXTX = RADIO_RST;           //<- RST
      contadorSeg_TX=0;
      contadorSeg_RX=0;
      contador200mS = NumTiemDesfaseTX;     //Fuerza que no exista Desfase
    }

    if(RADIO.statusRXTX == RADIO_RX)             //-> Configurado para recibir
    {
      if(RADIO.flagRx == 0)                   //Nota ha recibido datos de confirmacion
      {
        if ((contadorSeg_RX - segundosEsperaRX) >= 0)
        {
          flagEnvio = 0;
          contadorSeg_RX = 0;                       //Inicializa contador de seg RX
          contadorSeg_TX=0;                         //Inicializa contador de seg TX
          RADIO.statusRXTX = RADIO_RST;

          NumTiemDesfaseTX = rand() % 50;         //Establece que el tiempo maximo de desfase sera 10 segundos
          contador200mS = 0;
        }
      }
      else                                   //recibio los datos
      {
        NumTiemDesfaseTX = rand() % 50;         //Establece que el tiempo maximo de desfase sera 10 segundos
        contador200mS = 0;

        flagEnvio = 0;                                  //Forza al estado de TX siempre y cuando se cumplan las condiciones
        RADIO.statusRXTX = RADIO_RST;                   //Forza al estado de TX siempre y cuando se cumplan las condiciones

        if(RADIO.crc == 1)                             //ERROR
        {
          RADIO.crc = 0;
        }
        else
        {
          if(RADIO.dataLenRX == 4)       //Nota, son 4 bytes de confirmacion
          {
            for (i=0; i< 4; i++)                        //Extrae los datos del  los datos de SENSOR a la TRAMA
            {
              recibidoConfirmacion[i] = RADIO.frameRX[i];
            }
            if( (recibidoConfirmacion[0] == NumeroEsclavo) && (recibidoConfirmacion[1] == NumeroMaestro) )
            {
              if(recibidoConfirmacion[3] == NumeroRandomTrama)         //Se confirma que la ultima trama, la recibio el maestro
              {
                radio_mode(RADIO_RST);          //Coloca el dispositivo a Dormir
                if(cantidadPendienteTX > 1)          //Tiene pendiente la TX de antiguas tramas?
                {//Es necesario desplazar/rotar tramaPendienteTX[]  5 posiciones
                  cantidadPendienteTX--;
                  //rotarTramaPendienteTX(); ->//Tarea de rotar vector de almacenamiento de tramas pendientes
                  for (i=0; i<(cantidadPendienteTX*5);i++)
                  {
                    tramaPendienteTX[i]=tramaPendienteTX[i+5];
                  }
                }
                else
                {
                  cantidadPendienteTX = 0;      //No tiene tramas pendientes por enviar
                }
              }
            }
          }
          else
          {
          }
        }
      }
    }

    if((contadorSegSensor - tiempoTomaMuestraSensor) >= 0)             //Se cumplio el tiempo de tomar la muestra...se debe tomar la muestra del sensor
    {
      contadorSegSensor = 0;
      //cargarSensor_TramaPendienteTX();        //incrementa la cantidad pendientes de tramas, ademas de Simula el valor del SENSOR
      //Finaliza Emular tomar dato de un sensor sensor
      cantidadPendienteTX++;

      if((cantidadPendienteTX > 0) && (cantidadPendienteTX < 31))
      {
        j=(cantidadPendienteTX -1)*5;                 //Solamente almacena el Byte Random y los 4 bytes de informacion
        tramaPendienteTX[j] = rand() % 255;           //establece el numero RANDOM de la Trama, como comprobacion

        //Emula tomar dato de un sensor sensor
        for(i=0; i<4; i++)				//Funcion Unidades, decenas, centenas miles....
        {
          switch(i)
          {
            case 0:
              mult = 1000;
              break;
            case 1:
              mult = 100;
              break;
            case 2:
              mult = 10;
              break;
            case 3:
              mult = 1;
              break;
          }
          /*mult = pow(10,(3-i));			//1000   100  10 1*/
          j++;                                       //ajuste, lo hace antes ajustes
          tramaPendienteTX[j] = (uint8_t) CONTADOR / mult;    //
          mult = CONTADOR % mult;
        }
        //finaliza Emular tomar dato de un sensor sensor
        CONTADOR++;
      }
    }
    vTaskDelay(1);
  }
}
/**
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
  /* STM32L4xx HAL library initialization:
       - Configure the Flash prefetch
       - Systick timer is configured by default as source of time base, but user 
         can eventually implement his proper time base source (a general purpose 
         timer for example or other time source), keeping in mind that Time base 
         duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
         handled in milliseconds basis.
       - Set NVIC Group Priority to 4
       - Low Level Initialization
     */
  HAL_Init();

  /* Configure the system clock to 80 MHz */
  SystemClock_Config();
  
  xTaskCreate(TestLoraMultiple_Task, "TestLoraMultiple_Task", TEST_LORA_TASK_STACK, NULL, TEST_LORA_TASK_PRIORITY, &testLoraMultipleTask_Handle);
	xTaskCreate(TestLoraTimer_Task, "TestLoraTimer_Task", 35, NULL, TEST_LORA_TASK_PRIORITY, &testLoraTimerTask_Handle);
	xTaskCreate(TestLoraTimer2_Task, "TestLoraTimer2_Task", 35, NULL, TEST_LORA_TASK_PRIORITY, &testLoraTimer2Task_Handle);
  vTaskStartScheduler();
}


/**
  * @brief  System Clock Configuration
  *         The system Clock is configured as follows :
  *            System Clock source            = PLL (MSI)
  *            SYSCLK(Hz)                     = 80000000
  *            HCLK(Hz)                       = 80000000
  *            AHB Prescaler                  = 1
  *            APB1 Prescaler                 = 1
  *            APB2 Prescaler                 = 1
  *            MSI Frequency(Hz)              = 4000000
  *            PLL_M                          = 1
  *            PLL_N                          = 40
  *            PLL_R                          = 2
  *            PLL_P                          = 7
  *            PLL_Q                          = 4
  *            Flash Latency(WS)              = 4
  * @param  None
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};

  /* MSI is enabled after System reset, activate PLL with MSI as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 40;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLP = 7;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    /* Initialization Error */
    while(1);
  }
  
  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 
     clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;  
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;  
  if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    /* Initialization Error */
    while(1);
  }
}

#ifdef  USE_FULL_ASSERT

/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(char *file, uint32_t line)
{
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1)
  {
  }
}
#endif

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
