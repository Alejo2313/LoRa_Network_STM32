/** @file modbus_main.c

	@author Álvaro Gutíerrez and Marina Calvo
	@author Robolabo
	@date 2013/10/25 - Edición base.

	Implementation of functions that handle reading and writing of modbus

    COPYRIGHT NOTICE:
    This software is property of Robolabo. Its reproduction,  total or  par-
    tial, by any means, in any form, permanent or temporary, is forbidden
    unless explicitly authorised by Robolabo.
    Any adaptation, amendment, translation or transformation, as well as
    the decompiling or disassembly of this software  product, shall only
    be performed with the explicit authorization of Robolabo.
    The user of the present software product shall be allowed  to make a
    backup copy  as long as it is necessary  for the utilization  of the
    same.
    The terms stated above shall be understood  affecting that stated in
    applicable Laws. */

//*************************************************************
// IMPORTANT NOTE: THIS IS JUST A TEST, THIS CODE DOESN'T DO
// ANYTHING AT ALL. IT WAS WRITTEN JUST FOR THE SAKE OF TESTING
// MODBUS CONFIGURATION!!!
// ************************************************************

//************************************************************
// Includes
//************************************************************
#include "main.h"
#include "stm32l432xx.h"
#include "mb.h"
#include "common.h"
#include "port.h"

//************************************************************
// Useless defines
//************************************************************
#define THERMOCOUPLE 1
#define THERM_N_SENSORS 8
#define N_LEDS 4

//************************************************************
// Variables
//************************************************************
uint16_t usRegInputBuf[10]={1100, 2200, 3300, 4400, 5500, 6600, 7700, 8800, 9900, 1010};
uint16_t *usRegHoldingBuf=usRegInputBuf;	

//uint16_t fake_sensor_values[THERM_N_SENSORS]={0x0000,0x0001,0x0010,0x0011,0x0100,0x0101,0x0110,0x0111};
uint16_t fake_sensor_values[THERM_N_SENSORS]={0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000};

uint16_t REG_T0_INPUT_START=0, REG_T1_INPUT_START=100, REG_T2_INPUT_START=200, REG_T3_INPUT_START=300, REG_T4_INPUT_START=400, REG_HOLDING_START=500, REG_MODULE_INFO_START=600, REG_THERM_INFO=700, REG_READ_SWITCH=800, REG_TOGGLE_LED=900, REG_SAI_INPUT_START=0;
uint8_t usRegInputStart=0,usRegHoldingStart=0,N_REG_MODULE_INFO=2;

//************************************************************
// eMBRegInputCB
// If a reading message is receive from MODBUS master, 
// it stores the request values, selected with the number
// of register received, in pucRegBuffer
//************************************************************
  eMBErrorCode
eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
  eMBErrorCode    eStatus = MB_ENOERR;
  int             iRegIndex;
  uint16_t tmp;
  uint8_t  modbus_boardID = THERMOCOUPLE;
  uint8_t REG_INPUT_NREGS, N_REGS_THERM_INFO;
  REG_INPUT_NREGS = THERM_N_SENSORS;
  N_REGS_THERM_INFO = THERM_N_SENSORS + 1;

  /* If hardware ID and/or software version is read */
  if( ( usAddress >= REG_MODULE_INFO_START ) && ( usAddress + usNRegs <= REG_MODULE_INFO_START + N_REG_MODULE_INFO ) )
  {

    iRegIndex = ( int )( usAddress - REG_MODULE_INFO_START );

    while( usNRegs > 0 )
    {
      if(iRegIndex == 0)
        tmp = (uint16_t) modbus_boardID; // Return hardware ID
      else if(iRegIndex == 1)
        tmp =(uint16_t)1; // Return software version

      *pucRegBuffer++ = ( unsigned char ) ( tmp >> 8 );
      *pucRegBuffer++ = ( unsigned char )( tmp & 0xFF ); 	
      iRegIndex++;
      usNRegs--;
    }
  }
  /* If switch value is read */
  else if ( (usAddress >= REG_READ_SWITCH) && (usAddress + usNRegs <= REG_READ_SWITCH + 1) )
  {
    iRegIndex = ( int )( usAddress - REG_READ_SWITCH );
    tmp = (uint16_t)8;

    while( usNRegs > 0 )
    {
      *pucRegBuffer++ = ( unsigned char ) ( tmp >> 8 );
      *pucRegBuffer++ = ( unsigned char )( tmp & 0xFF ); 	
      iRegIndex++;
      usNRegs--;
    }
  }
  /* If the module is not a UPS */
  else if ( modbus_boardID != SAI)
  {	
    /* If T0 samples are read */
    if( ( usAddress >= REG_T0_INPUT_START )&& ( usAddress + usNRegs <= REG_T0_INPUT_START + REG_INPUT_NREGS ) )
    {
      iRegIndex = ( int )( usAddress - REG_T0_INPUT_START );

      while( usNRegs > 0 )
      {
        tmp = (uint16_t) fake_sensor_values[iRegIndex];
        *pucRegBuffer++ = ( unsigned char ) ( tmp >> 8 );
        *pucRegBuffer++ = ( unsigned char )( tmp & 0xFF ); 	
        iRegIndex++;
        usNRegs--;
      }
    }
    /* If T1 medians are read */
    else if( ( usAddress >= REG_T1_INPUT_START )&& ( usAddress + usNRegs <= REG_T1_INPUT_START + REG_INPUT_NREGS ) )
    {
      iRegIndex = ( int )( usAddress - REG_T1_INPUT_START );

      while( usNRegs > 0 )
      {
        tmp = (uint16_t) fake_sensor_values[iRegIndex];
        *pucRegBuffer++ = ( unsigned char ) ( tmp >> 8 );
        *pucRegBuffer++ = ( unsigned char )( tmp & 0xFF ); 	
        iRegIndex++;
        usNRegs--;
      }
    }
    /* If T2 medians are read */
    else if( ( usAddress >= REG_T2_INPUT_START )&& ( usAddress + usNRegs <= REG_T2_INPUT_START + REG_INPUT_NREGS ) )
    {
      iRegIndex = ( int )( usAddress - REG_T2_INPUT_START );

      while( usNRegs > 0 )
      {
        tmp = (uint16_t) fake_sensor_values[iRegIndex];
        *pucRegBuffer++ = ( unsigned char ) ( tmp >> 8 );
        *pucRegBuffer++ = ( unsigned char )( tmp & 0xFF ); 	
        iRegIndex++;
        usNRegs--;
      }
    }
    /* If T3 medians are read */
    else if( ( usAddress >= REG_T3_INPUT_START )&& ( usAddress + usNRegs <= REG_T3_INPUT_START + REG_INPUT_NREGS ) )
    {
      iRegIndex = ( int )( usAddress - REG_T3_INPUT_START );

      while( usNRegs > 0 )
      {
        tmp = (uint16_t) fake_sensor_values[iRegIndex];
        *pucRegBuffer++ = ( unsigned char ) ( tmp >> 8 );
        *pucRegBuffer++ = ( unsigned char )( tmp & 0xFF ); 	
        iRegIndex++;
        usNRegs--;
      }
    }
    /* If T4 medians are read */
    else if( ( usAddress >= REG_T4_INPUT_START )&& ( usAddress + usNRegs <= REG_T4_INPUT_START + REG_INPUT_NREGS ) )
    {
      iRegIndex = ( int )( usAddress - REG_T4_INPUT_START );

      while( usNRegs > 0 )
      {
        tmp = (uint16_t) fake_sensor_values[iRegIndex];
        *pucRegBuffer++ = ( unsigned char ) ( tmp >> 8 );
        *pucRegBuffer++ = ( unsigned char )( tmp & 0xFF ); 	
        iRegIndex++;
        usNRegs--;
      }
    }
    /* If configuration of inputs is read */
    else if( ( usAddress >= REG_HOLDING_START )&& ( usAddress + usNRegs <= REG_HOLDING_START + REG_INPUT_NREGS ) )
    {
      iRegIndex = ( int )( usAddress - REG_HOLDING_START );

      while( usNRegs > 0 )
      {
        tmp = (uint16_t) 0x00;
        *pucRegBuffer++ = ( unsigned char ) ( tmp >> 8 );
        *pucRegBuffer++ = ( unsigned char )( tmp & 0xFF ); 	
        iRegIndex++;
        usNRegs--;
      }
    }
    /* If thermocouple module internal sensor is read */
    else if((modbus_boardID == THERMOCOUPLE) && (usAddress >= REG_THERM_INFO) && (usAddress + usNRegs <= REG_THERM_INFO + 1))
    {
      iRegIndex = ( int )( usAddress - REG_THERM_INFO );
      while( usNRegs > 0 )
      {
        tmp = (uint16_t) fake_sensor_values[iRegIndex];
        *pucRegBuffer++ = ( unsigned char ) ( tmp >> 8 );
        *pucRegBuffer++ = ( unsigned char )( tmp & 0xFF );
        iRegIndex++;
        usNRegs--;
      }

    }
    /* If voltage of thermocouple inputs are read*/
    else if((modbus_boardID == THERMOCOUPLE) && (usAddress >= REG_THERM_INFO + 1) && (usAddress + usNRegs <= REG_THERM_INFO + N_REGS_THERM_INFO))
    {
      iRegIndex = ( int )( usAddress - REG_THERM_INFO -1 );
      while( usNRegs > 0 )
      {
        tmp = (uint16_t) fake_sensor_values[iRegIndex];
        *pucRegBuffer++ = ( unsigned char ) ( tmp >> 8 );
        *pucRegBuffer++ = ( unsigned char )( tmp & 0xFF );
        iRegIndex++;
        usNRegs--;
      }

    }
  }
  /* If wrong register number */
  else
  {
    eStatus = MB_ENOREG;
  }

  return eStatus;
}

//************************************************************
// eMBRegHoldingCB
// If a writing message is received from MODBUS master, 
// it stores the received values in the corresponding array
// depending on the number of register selected by the master.
//************************************************************
	eMBErrorCode
eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs, eMBRegisterMode eMode )
{
	eMBErrorCode    eStatus = MB_ENOERR;
	int             iRegIndex;
	UCHAR tmp;
  uint8_t modbus_boardID = THERMOCOUPLE;
  uint8_t REG_HOLDING_NREGS;
  REG_HOLDING_NREGS = THERM_N_SENSORS;
        
  /* If configuration registers are written */
  if( ( usAddress >= REG_HOLDING_START ) && ( usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS ) )
  {
    iRegIndex = ( int )( usAddress - REG_HOLDING_START );

    switch ( eMode )
    {
      case MB_REG_READ:
        while( usNRegs > 0 )
        {
          *pucRegBuffer++ = ( unsigned char )( usRegHoldingBuf[iRegIndex] >> 8 );
          *pucRegBuffer++ = ( unsigned char )( usRegHoldingBuf[iRegIndex] & 0xFF );
          iRegIndex++;
          usNRegs--;
        }
        break;

      case MB_REG_WRITE:
        while( usNRegs > 0 )
        {

          tmp = *pucRegBuffer++ << 8;
          tmp |= *pucRegBuffer++;

          iRegIndex++;
          usNRegs--;
        }
    }
  }
  /* LEDs status is written*/
  else if( ( usAddress >= REG_TOGGLE_LED ) && ( usAddress + usNRegs <= REG_TOGGLE_LED + N_LEDS ) )
  {
    iRegIndex = ( int )( usAddress - REG_TOGGLE_LED );

    switch ( eMode )
    {
      case MB_REG_READ:
        while( usNRegs > 0 )
        {
          *pucRegBuffer++ = ( unsigned char )( usRegHoldingBuf[iRegIndex] >> 8 );
          *pucRegBuffer++ = ( unsigned char )( usRegHoldingBuf[iRegIndex] & 0xFF );
          iRegIndex++;
          usNRegs--;
        }
        break;

      case MB_REG_WRITE:
        while( usNRegs > 0 )
        {
          tmp = *pucRegBuffer++ << 8;
          tmp |= *pucRegBuffer++;

          iRegIndex++;
          usNRegs--;
        }
        break;
    }
  }
  else
  {
    eStatus = MB_ENOREG;
  }

	return eStatus;
}

	eMBErrorCode
eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils, eMBRegisterMode eMode )
{
	( void )pucRegBuffer;
	( void )usAddress;
	( void )usNCoils;
	( void )eMode;
	return MB_ENOREG;
}

	eMBErrorCode
eMBRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
{
	( void )pucRegBuffer;
	( void )usAddress;
	( void )usNDiscrete;
	return MB_ENOREG;
}
