/*
 * main_2.c
 *
 *  Created on: 16 oct. 2018
 *      Author: Alejo
 */


//#define NODE 


#define DEBUG
/*Includes*/
#include "cmsis_os.h"
#include "hw.h"						//Hardware configuration
#include "radio.h"					//phy mac implementation
#include "timeServer.h"				//Timer driver implementation
#include "low_power_manager.h"		//Power manager
#include "types.h"

//#define NODE

#define RF_FREQUENCY		868000000		//Europe band
#define TX_OUTPUT_POWER_DF		14				//dNm

#define RX_TIMEOUT_VALUE                            1000

/*Lora settings */

#define LORA_BANDWIDTH_DF                           0         // [0: 125 kHz,
                                                              //  1: 250 kHz,
                                                              //  2: 500 kHz,
                                                              //  3: Reserved]
#define LORA_SPREADING_FACTOR_DF                       7         // [SF7..SF12]
#define LORA_CODINGRATE                             1         // [1: 4/5,
                                                              //  2: 4/6,
                                                              //  3: 4/7,
                                                              //  4: 4/8]
#define LORA_PREAMBLE_LENGTH                        8         // Same for Tx and Rx
#define LORA_SYMBOL_TIMEOUT                         0         // Symbols
#define LORA_FIX_LENGTH_PAYLOAD_ON                  false
#define LORA_IQ_INVERSION_ON                        false




/* MPU settings */

#define RX_WINDOW			100
#define BUFFER_SIZE			64   		//128, 256
#define USE_ACK				true


#define DEV_ADDR			0x1A2B
#define HEAD_SIZE			7


/* Variables */

Packet_t* RxData;
Packet_t* TxData;

State_t State = SLEEP_S;						// Actual state

int8_t Rssi = 0;								//RX power
int8_t Snr = 0;									//Signal/Noise ratio
int8_t	SfRx = LORA_SPREADING_FACTOR_DF;		//Actual Spreading factor
int8_t	SfTx = LORA_SPREADING_FACTOR_DF;		//Actual Spreading factor
uint16_t Bw = LORA_BANDWIDTH_DF;
uint8_t	TxPower = TX_OUTPUT_POWER_DF;


LPTIM_HandleTypeDef hlptim1;


bool exe = false;

static int cont = 0;
static Error_t ErroType = NO_ERROR;

/* radio */
static RadioEvents_t RadioEvents;

void onTxDone();			//Tx Done callback
void onTxTimeout();			//Tx Timeout callback prototype
void onRxDone( uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr );			// Rx Done callback prototype
void onRxTimeout();			//Rx Timeout callback prototype.
void onRxError();			//Rx Error callback prototype.
void onFhssChangeChannel(uint8_t currentChannel);	//HSS Change Channel callback prototype;
void onCadDone(bool channelActivityDetected);


/* private prototypes */
static void MX_LPTIM1_Init(void);
void radio_init();
void loadInfo();
void configure();
void errorHandle();
void measure();
void sendPack();
void print();
void fire();
void sendAck();

void parser(uint8_t* pData, uint16_t size);

void ledBlinkTask();


int main(){

	 
	HAL_Init();

	BSP_LED_Init(LED_BLUE);
	BSP_LED_Init(LED_GREEN);
	BSP_LED_Init(LED_RED1);


	SystemClock_Config();
	HW_Init();
	radio_init();
	LPM_SetOffMode(LPM_APPLI_Id, LPM_Enable );
	MX_LPTIM1_Init();
	HAL_LPTIM_Counter_Start_IT(&hlptim1, 0XFFFF);

	while(1){

	}

#ifdef NODE
	osThreadDef(FSM, fire, osPriorityRealtime,0, 512);
	osThreadCreate(osThread(FSM), NULL);
	BSP_LED_On(LED_BLUE);

#else
	Radio.Rx( 0);
	BSP_LED_On(LED_RED1);
#endif

	osKernelStart();
	while(1){
	}

}







void radio_init(){
	RadioEvents.TxDone = onTxDone;
	RadioEvents.TxTimeout = onTxTimeout;
	RadioEvents.RxDone = onRxDone;
	RadioEvents.RxTimeout = onRxTimeout;
	RadioEvents.RxError = onRxError;
	RadioEvents.FhssChangeChannel = onFhssChangeChannel;
	RadioEvents.CadDone = onCadDone;

	Radio.Init( &RadioEvents );
	Radio.SetChannel( RF_FREQUENCY );

	Radio.SetTxConfig( MODEM_LORA, TxPower, 0, Bw, SfRx, LORA_CODINGRATE,
	                                   LORA_PREAMBLE_LENGTH, LORA_FIX_LENGTH_PAYLOAD_ON,
	                                   true, 0, 0, LORA_IQ_INVERSION_ON, 3000 );

	Radio.SetRxConfig( MODEM_LORA, Bw, SfTx,LORA_CODINGRATE, 0, LORA_PREAMBLE_LENGTH,
	                                   LORA_SYMBOL_TIMEOUT, LORA_FIX_LENGTH_PAYLOAD_ON,
	                                   0, true, 0, 0, LORA_IQ_INVERSION_ON, true );

}

/*
 *
 */

void fire(){
	while(1){
		switch(State){
			case SLEEP_S:
			#ifdef DEBUG
				PRINTF("--> SLEEP STATE \r \n");
			#endif
				osDelay(1000);
				State = MEASURE;
				break;

			case MEASURE:
			#ifdef DEBUG
				PRINTF("--> MEASURE STATE \r \n");
			#endif
				measure();
				State = TX_S;
				break;

			case TX_S:
				if(!exe){
					sendPack();
					exe = true;
				}
				break;

			case RX_S:
				if(!exe){
					Radio.Rx(1000);
					exe = true;
				}
				break;
			case CONFIG_S:
				configure();
				State = SLEEP_S;
			break;

			case ERROR_HANDLE:
				errorHandle();
			break;

			default:
			#ifdef DEBUG
				PRINTF("erro?! \r \n");
			#endif
				State = SLEEP_S;
				break;
		}
	}
}


/*
 *
 */

void onTxDone(){
#ifdef DEBUG
	PRINTF("Transmition done! \r \n");
#endif
#ifdef NODE
	Radio.Sleep( );
	State = RX_S;
	exe = false;

#else
	Radio.Rx(0);
#endif



}

/*
 *
 */
void onTxTimeout(){
#ifdef DEBUG
	PRINTF("Transmition fail! -> timeout \r \n");
#endif
#ifdef NODE
	Radio.Sleep( );
#endif

	State = ERROR_HANDLE;
	ErroType = TX_TIMEOUT;
	exe = false;
}

/*
 *
 */

void onRxDone( uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr ){

#ifdef NODE
	Radio.Sleep( );
#endif

	if(size < 4)
		return;

	exe = false;
	parser(payload, size);
	print(RxData);
	switch(RxData->MacType){
		case ACK:
			State = SLEEP_S;
		#ifdef DEBUG
			PRINTF("RX ok! -> ACK \r \n");
		#endif
			break;


		case NACK:
			State = ERROR_HANDLE;
			ErroType = RX_NACK;
		#ifdef DEBUG
			PRINTF("RX ERROR! -> NACK \r \n");
		#endif
			break;

		case TX_T:
			switch(RxData->type){
		#ifdef NODE
				case CONFIG:
					State = CONFIG;
					break;	
		#else
				case DATA:
					//print(RxData);
					break;
		#endif
				case REQ_INFO:
					loadInfo();
					State = TX_T;
					break;
			}
			if(USE_ACK){
				sendAck();
			}
			break;

		default:
			State = SLEEP_S;
			break;
	}
}



void onRxTimeout(){

#ifdef DEBUG
	PRINTF("Error: Timeout \r \n");
#endif
#ifdef NODE
	Radio.Sleep( );
#endif
	exe = false;
	if(USE_ACK){
		State = ERROR_HANDLE;
		ErroType = RX_TIMEOUT;
	}
	else{
		State = SLEEP_S;
	}
}


void parser(uint8_t* pData, uint16_t size){

	if(RxData == NULL)
		RxData= (Packet_t*)malloc(sizeof(Packet_t));

	RxData->NettAddr = *(pData++);
	RxData->devAddr = (*(pData++)<< 8) | (*(pData++)&0xFF);
	RxData->devDest = (*(pData++)<< 8) | (*(pData++)&0xFF);
	RxData->MacType = (*(pData)>>4)&0xF;
	RxData->flags = *(pData++)&0xF;
	RxData->pSize = *(pData++);
	RxData->type =	*(pData++);

	free(RxData->pData);
	RxData->pData = (uint8_t*)malloc(RxData->pSize - 1); 
	memcpy(RxData->pData, pData ,RxData->pSize  - 1);

}

//TODO -> ajustar los limites del payload

void sendPack(){
	static uint8_t* sendData = NULL;

	PRINTF("Sending data: \r\n");
	print(TxData);

	if(sendData !=  NULL)
		free(sendData);

	uint8_t totalSize = TxData->pSize + HEAD_SIZE;
	sendData = (uint8_t*)malloc(totalSize);
	*(sendData++) = (TxData->NettAddr);
	*(sendData++) = (TxData->devAddr>>8)&0xFF;
	*(sendData++) = (TxData->devAddr)&0xFF;
	*(sendData++) = (TxData->devDest >> 8)&0xFF;
	*(sendData++) = (TxData->devDest)&0xFF;
	*(sendData++) = (TxData->MacType << 4)| TxData->flags;
	*(sendData++) = (TxData->pSize);
	*(sendData++) = (TxData->type);
	memcpy(sendData, TxData->pData, TxData->pSize -1);
	
	Radio.Send(sendData - HEAD_SIZE -1, totalSize);

}




void measure(){
	if(TxData == 0){
		TxData = (Packet_t*)malloc(sizeof(Packet_t));
	}
	uint8_t* mess = "01234";
	TxData->NettAddr = 0xFF;
	TxData->devAddr = DEV_ADDR;
	TxData->devDest = 0xFFFF;
	TxData->MacType = 0;
	TxData->flags = 0;
	TxData->pData = mess;
	TxData->type = DATA;
	TxData->pSize = 5;
}





void print(Packet_t *data){
	if(data == NULL){
		PRINTF("Error printing: DATA NULL \r \n");
		return;
	}
	char str[512];
	sprintf(str, "\t  Net Address: %X \r\n\t device Address: %X \r\n\t Source Address: %X \r\n\t mac type: %X \r\n\t Size: %X \r\n", data->NettAddr, data->devAddr, data->devDest, data->MacType, data->pSize);

	PRINTF(str);
}


void loadInfo(){

};
void onRxError(){
	exe = false;

#ifdef DEBUG
	PRINTF("RX ERROR \r \n");
#endif
	Radio.Sleep( );
	State = SLEEP_S;
}

void onFhssChangeChannel(uint8_t currentChannel){};	//HSS Change Channel callback prototype;
void onCadDone(bool channelActivityDetected){}



void errorHandle(){
	PRINTF("ERROR HANDLE \n");
}

void configure(){};








void sendAck(){
	if(TxData == 0){
		TxData = (Packet_t*)malloc(sizeof(Packet_t));
	}
	uint8_t* mess = "01234";
	TxData->NettAddr = 0xFF;
	TxData->devAddr = DEV_ADDR;
	TxData->devDest = 0xFFFF;
	TxData->MacType = ACK;
	TxData->flags = 0;
	TxData->pData = mess;
	TxData->type = DATA;
	TxData->pSize = 5;
	sendPack();
} 















//more shit
void ledBlinkTask(){
	BSP_LED_Init(LED_GREEN);
	while(1){
		BSP_LED_Toggle(LED_GREEN);
		osDelay(500);
	}
	osThreadTerminate(NULL);
	
}



static void MX_LPTIM1_Init(void)
{
  hlptim1.Instance = LPTIM1;
  hlptim1.Init.Clock.Source = LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC;
  hlptim1.Init.Clock.Prescaler = 1024;
  hlptim1.Init.Trigger.Source = LPTIM_TRIGSOURCE_SOFTWARE;
  hlptim1.Init.OutputPolarity = LPTIM_OUTPUTPOLARITY_HIGH;
  hlptim1.Init.UpdateMode = LPTIM_UPDATE_IMMEDIATE;
  hlptim1.Init.CounterSource = LPTIM_COUNTERSOURCE_INTERNAL;
  if (HAL_LPTIM_Init(&hlptim1) != HAL_OK)
  {
  }
  __HAL_RCC_LPTIM1_CLK_ENABLE();
	HAL_NVIC_SetPriority(LPTIM1_IRQn,0, 0);
	HAL_NVIC_EnableIRQ(LPTIM1_IRQn);
}
void LPTIM1_IRQHandler(void)
{
HAL_LPTIM_IRQHandler(&hlptim1);
HAL_NVIC_ClearPendingIRQ(LPTIM1_IRQn);
PRINTF("HOLAA \r \n");
		BSP_LED_Toggle(LED_GREEN);


} 